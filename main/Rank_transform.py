#setting sys.path for importing modules
import os
import sys

if __name__ == "__main__":
         abspath= __file__
         parent_module= "/".join(abspath.split("/")[:-2])
         sys.path.insert(0, parent_module)

import argparse
import numpy as np

from data_processing import read_write , network

def get_zscore(np_array, flip_scores = True):
    std_deviation = np.nanstd(np_array)
    ret_array = np_array - np.nanmean(np_array)
    if flip_scores: # convert polarity of scores. i.e. smaller, stronger -> Larger, stronger
        return -1 * (ret_array / std_deviation)
    else:
         return (ret_array / std_deviation)

if __name__ == "__main__":
    parser= argparse.ArgumentParser(description="Rank_transform.py\n\
                                            calculate Mutual Ranks (MR) and Highest reciprocal ranks (HRR) and their standardized forms raw correlation scores.\n\
                                    Rank_transform.py outputs the final complete TEA-GCN as directory separate from the intermediate TEA-GCN generated by Run_TEA_GCN.py")
    parser.add_argument("-o", "--output_dir", type=str, metavar="", required = True,
                        help = "Working directory containing required data of which to output data. Must be same as output_dir for Run_TEA_GCN.py and Generate_partitions.py" )
    parser.add_argument("-n", "--net_name" , type=str, metavar = "" , default = "All",
                        help = "name of network to calculate MR and HRR for. By default, all networks will be calculated")
    parser.add_argument("-d", "--delete_net" , type=str, metavar = "" , default = False,
                        help = "If set to True, Rank_transform.py will delete intermediate TEA-GCN generated by Run_TEA_GCN.py. False by default.")
    
    parser.add_argument("-full", "--full_attribute" , type=str, metavar = "" , default = False,
                        help = "If set to True, Rank_transform.py will output full set of attributes for every edge which includes: raw co-exp. strengths, MR, HRR, and their Z score variants.\
                            False by default where only raw co-exp, MR and Z(MR) is reported.")
    
    args=parser.parse_args()
    output_dir = args.output_dir
    net_name = args.net_name
    BGCN_sub_outdir = os.path.join(output_dir , "RAW_GCN")
    sub_outdir = os.path.join(output_dir , "Completed_GCN")
    full_attribute = args.full_attribute
    delete_net = args.delete_net

    All_networks_paths =[]
    for cc in ["PCC", "SCC", "bicor", "TEA" ]:
           if os.path.exists(os.path.join(BGCN_sub_outdir, cc)):
                netdirs = os.listdir(os.path.join(BGCN_sub_outdir, cc))
                for netdir in netdirs:
                        if "k" in netdir:
                            All_networks_paths.append(os.path.join( BGCN_sub_outdir, cc, netdir))
            
    if net_name == "All":
        print(f"net_name={net_name} specified by user.\nProceeding to process these networks:")
        out = [print(network_path) for network_path in All_networks_paths]
    else:
        print(f"net_name={net_name} specified by user.\nProceeding to process:")
        All_networks_paths = [network_path for network_path in All_networks_paths if net_name.lower() in network_path.lower()]
        try:
            print(All_networks_paths[0])
        except:
            sys.exit(f"{net_name} network not found!")
    
    #start main loop
    for network_path in All_networks_paths:
        if full_attribute: #i.e. output full edge attributes 
            print(f"Loading network: {network_path}\n into adjacency matrix")
            genes , upper_half, lower_half, upper_half_cor, gene_dict = network.extract_ranks(network_path)
            
            print("Calculating HRR and MR of all edges...")
            HRR_array = np.max([upper_half , lower_half], axis = 0)
            print("HRR calculated")
            MR_array = np.sqrt(upper_half * lower_half)
            print("MR calculated")
            
            HRR_zscore_array= get_zscore(HRR_array, flip_scores = True )
            print("zscore HRR calculated")

            cor_zscore_array =  get_zscore(upper_half_cor, flip_scores = False)
            print("zscore of raw co-expression strength calculated")

            MR_zscore_array = get_zscore(MR_array, flip_scores = True)
            print("zscore of raw co-expression strength calculated")

            del upper_half, lower_half

            print("Writing ranks to new network at:")
            network_outpath = os.path.join( sub_outdir , network_path.split("/")[-1])
            read_write.establish_dir(network_outpath, isdir = True)
            print(network_outpath)
            network.write_all_edge_attributes(gene_dict, HRR_array, MR_array, cor_zscore_array, HRR_zscore_array,MR_zscore_array, network_path, network_outpath, genes)
        
        else:
            print(f"Loading network: {network_path}\n into adjacency matrix")
            genes , upper_half, lower_half, upper_half_cor, gene_dict = network.extract_ranks(network_path)
            
            print("Calculating MR of all edges...")
            MR_array = np.sqrt(upper_half * lower_half)
            print("MR calculated")

            MR_zscore_array = get_zscore(MR_array, flip_scores = True)
            print("zscore of raw co-expression strength calculated")

            del upper_half, lower_half

            print("Writing ranks to new network at:")
            network_outpath = os.path.join( sub_outdir , network_path.split("/")[-1])
            read_write.establish_dir(network_outpath, isdir = True)
            print(network_outpath) 
            network.write_MR_attributes_only(gene_dict, MR_array,  MR_zscore_array, network_path, network_outpath, genes)

    if delete_net:
         print(f"Deleting intermediate TEA-GCN generated by Run_TEA-GCN.py located in {network_path}")
         os.system(f"rm -r {network_path}")
    print(f"Rank_transform.py finished running. Completed TEA-GCN generated at {network_outpath}")
    

    
